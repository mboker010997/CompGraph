## ComputeGraph

Библиотека для вычислений над графами.

```
Таблица - это последовательность словарей, где каждый словарь — это строка таблицы, а ключ словаря — колонка таблицы
(индекс в последовательности + ключ в словаре задают ячейку).
```

Над таблицами мы будем запускать вычисления, задавая их с помощью *вычислительных графов*.

Под вычислительным графом мы будем понимать заранее заданную последовательность операций, которую затем можно применять к
различным наборам данных.

Для простоты можно считать, что все строки во входных таблицах содержат одинаковый набор ключей.
При этом вашим операциям не запрещается создавать строки, у которых для некоторых ключей значения не определены, например:
`{'key1': 1, 'key2': None}`, но в этом случае необходимо сделать реализацию всех операций устойчивой к такому поведению.

### Зачем вообще нужны вычислительные графы?

Вычислительные графы позволяют отделить описание последовательности операций от их выполнения. Благодаря этому, вы можете как
запускать операции в другой среде (например, описать граф в интерпретаторе питона, а затем выполнить на видеокарте),
так и независимо и параллельно запускать на множестве машин вычислительного кластера для обработки большого массива
входных данных за адекватное конечное время (например, так работает клиент к системе распределенных вычислений Spark).


### Интерфейс графа вычислений

Граф вычислений состоит из точек входа для данных и операций над ними.

Вот так может выглядеть (хотя кого я пытаюсь обмануть, так и есть - см. [`compgraph/algorithms.py`](compgraph/algorithms.py)) граф,
который подсчитывает кол-во слов в документах:
```python
graph = Graph.graph_from_iter('texts') \
    .map(operations.FilterPunctuation('text')) \
    .map(operations.LowerCase('text')) \
    .map(operations.Split('text')) \
    .sort(['text']) \
    .reduce(operations.Count('count'), ['text']) \
    .sort(['count', 'text'])
```

Ещё раз заострим внимание: в момент создания графа мы не производим никаких чтений данных и вычислений.

Обратите внимание на интерфейс графа, каждая операция задается вызовом соответствующего метода класса `Graph`
(полный список операций см. в [`compgraph/graph.py`](compgraph/graph.py)) - это рекомендуемая реализация, которая тем не менее **не является
обязательной**. Вы можете менять интерфейс графа на своё усмотрение (единственное, что требуется - тесты должны
работать как есть, без изменений).

Входные данные могут подаваться как в виде имен файлов с таблицами, которые необходимо открыть и прочитать,
так и в виде произвольных генераторов, которые возвращают по одной строке за раз .

Таблицы в файлах хранятся в виде последовательностей json-словарей (по одному на строку), каждый из которых описывает
одну строку итоговой таблицы (см. директорию [`resources`](resources)).

Графы работают в стриминговой манере. Это означает, что никакая часть графа вычислений не должна накапливать
потенциально неограниченный набор значений в оперативной памяти.

**Очень важный момент**: нелинейность в графе может возникнуть и без `join`'а:
```python
graph = Graph().operation1(...).operation2(...)

# Caution! Non-linear execution flow
graph1 = graph.operation3()
graph2 = graph.operation4()

# Pure evil (he-he-he)
final_graph = graph1.join(..., graph2, ...)
```

### Как запустить тесты?

Перед тем, как запустить тесты, нужно установить библиотеку.

```bash
# Устанавливаем библиотеку compgraph
(shad_env)$ pip install -e compgraph --force-reinstall

# Стал доступен модуль compgraph в интерпретаторе
# Теперь можете запустить тесты, которые используют модуль compgraph в импортах
(shad_env)$ pytest compgraph
```
